import"./main.bb43548d.js";class M{constructor(t=0,s=0){this.x=t,this.y=s}clone(){return new this.constructor(this.x,this.y)}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,s){return Math.abs(this.x-t.x)<s&&Math.abs(this.y-t.y)<s}lerp(t,s){const e=1-s;return new this.constructor(this.x*e+t.x*s,this.y*e+t.y*s)}distanceFrom(t){const s=this.x-t.x,e=this.y-t.y;return Math.sqrt(s*s+e*e)}min(t){return new this.constructor(Math.min(this.x,t.x),Math.min(this.y,t.y))}max(t){return new this.constructor(Math.max(this.x,t.x),Math.max(this.y,t.y))}transform(t){return new this.constructor(t.a*this.x+t.c*this.y+t.e,t.b*this.x+t.d*this.y+t.f)}toString(){return`point(${this.x},${this.y})`}}class S{constructor(t=0,s=0){this.x=t,this.y=s}static fromPoints(t,s){return new S(s.x-t.x,s.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitude(){return this.x*this.x+this.y*this.y}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}determinant(t){return this.x*t.y-this.y*t.x}unit(){return this.divide(this.length())}add(t){return new this.constructor(this.x+t.x,this.y+t.y)}subtract(t){return new this.constructor(this.x-t.x,this.y-t.y)}multiply(t){return new this.constructor(this.x*t,this.y*t)}divide(t){return new this.constructor(this.x/t,this.y/t)}angleBetween(t){let s=this.dot(t)/(this.length()*t.length());s=Math.max(-1,Math.min(s,1));const e=Math.acos(s);return this.cross(t)<0?-e:e}perp(){return new this.constructor(-this.y,this.x)}perpendicular(t){return this.subtract(this.project(t))}project(t){const s=this.dot(t)/t.dot(t);return t.multiply(s)}transform(t){return new this.constructor(t.a*this.x+t.c*this.y,t.b*this.x+t.d*this.y)}equals(t){return this.x===t.x&&this.y===t.y}precisionEquals(t,s){return Math.abs(this.x-t.x)<s&&Math.abs(this.y-t.y)<s}toString(){return`vector(${this.x},${this.y})`}}class F{constructor(t=1,s=0,e=0,i=1,n=0,o=0){this.a=t,this.b=s,this.c=e,this.d=i,this.e=n,this.f=o}static translation(t,s){return new F(1,0,0,1,t,s)}static scaling(t){return new F(t,0,0,t,0,0)}static scalingAt(t,s){return new F(t,0,0,t,s.x-s.x*t,s.y-s.y*t)}static nonUniformScaling(t,s){return new F(t,0,0,s,0,0)}static nonUniformScalingAt(t,s,e){return new F(t,0,0,s,e.x-e.x*t,e.y-e.y*s)}static rotation(t){const s=Math.cos(t),e=Math.sin(t);return new F(s,e,-e,s,0,0)}static rotationAt(t,s){const e=Math.cos(t),i=Math.sin(t);return new F(e,i,-i,e,s.x-s.x*e+s.y*i,s.y-s.y*e-s.x*i)}static rotationFromVector(t){const s=t.unit(),e=s.x,i=s.y;return new F(e,i,-i,e,0,0)}static xFlip(){return new F(-1,0,0,1,0,0)}static yFlip(){return new F(1,0,0,-1,0,0)}static xSkew(t){const s=Math.tan(t);return new F(1,0,s,1,0,0)}static ySkew(t){const s=Math.tan(t);return new F(1,s,0,1,0,0)}multiply(t){return this.isIdentity()?t:t.isIdentity()?this:new this.constructor(this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.e+this.c*t.f+this.e,this.b*t.e+this.d*t.f+this.f)}inverse(){if(this.isIdentity())return this;const t=this.a*this.d-this.b*this.c;if(t===0)throw new Error("Matrix is not invertible");const s=1/t,e=this.f*this.c-this.e*this.d,i=this.e*this.b-this.f*this.a;return new this.constructor(this.d*s,-this.b*s,-this.c*s,this.a*s,e*s,i*s)}translate(t,s){return new this.constructor(this.a,this.b,this.c,this.d,this.a*t+this.c*s+this.e,this.b*t+this.d*s+this.f)}scale(t){return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.e,this.f)}scaleAt(t,s){const e=s.x-t*s.x,i=s.y-t*s.y;return new this.constructor(this.a*t,this.b*t,this.c*t,this.d*t,this.a*e+this.c*i+this.e,this.b*e+this.d*i+this.f)}scaleNonUniform(t,s){return new this.constructor(this.a*t,this.b*t,this.c*s,this.d*s,this.e,this.f)}scaleNonUniformAt(t,s,e){const i=e.x-t*e.x,n=e.y-s*e.y;return new this.constructor(this.a*t,this.b*t,this.c*s,this.d*s,this.a*i+this.c*n+this.e,this.b*i+this.d*n+this.f)}rotate(t){const s=Math.cos(t),e=Math.sin(t);return new this.constructor(this.a*s+this.c*e,this.b*s+this.d*e,this.a*-e+this.c*s,this.b*-e+this.d*s,this.e,this.f)}rotateAt(t,s){const e=Math.cos(t),i=Math.sin(t),n=s.x,o=s.y,r=this.a*e+this.c*i,l=this.b*e+this.d*i,c=this.c*e-this.a*i,y=this.d*e-this.b*i;return new this.constructor(r,l,c,y,(this.a-r)*n+(this.c-c)*o+this.e,(this.b-l)*n+(this.d-y)*o+this.f)}rotateFromVector(t){const s=t.unit(),e=s.x,i=s.y;return new this.constructor(this.a*e+this.c*i,this.b*e+this.d*i,this.a*-i+this.c*e,this.b*-i+this.d*e,this.e,this.f)}flipX(){return new this.constructor(-this.a,-this.b,this.c,this.d,this.e,this.f)}flipY(){return new this.constructor(this.a,this.b,-this.c,-this.d,this.e,this.f)}skewX(t){const s=Math.tan(t);return new this.constructor(this.a,this.b,this.c+this.a*s,this.d+this.b*s,this.e,this.f)}skewY(t){const s=Math.tan(t);return new this.constructor(this.a+this.c*s,this.b+this.d*s,this.c,this.d,this.e,this.f)}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.e===0&&this.f===0}isInvertible(){return this.a*this.d-this.b*this.c!==0}getScale(){return{scaleX:Math.sqrt(this.a*this.a+this.c*this.c),scaleY:Math.sqrt(this.b*this.b+this.d*this.d)}}getDecomposition(){const t=(this.a+this.d)*.5,s=(this.a-this.d)*.5,e=(this.b+this.c)*.5,i=(this.b-this.c)*.5,n=Math.sqrt(t*t+i*i),o=Math.sqrt(s*s+e*e),r=n+o,l=n-o,c=Math.atan2(e,s),y=Math.atan2(i,t),x=(y-c)*.5,u=(y+c)*.5;return{translation:this.constructor.translation(this.e,this.f),rotation:this.constructor.rotation(u),scale:this.constructor.nonUniformScaling(r,l),rotation0:this.constructor.rotation(x)}}equals(t){return this.a===t.a&&this.b===t.b&&this.c===t.c&&this.d===t.d&&this.e===t.e&&this.f===t.f}precisionEquals(t,s){return Math.abs(this.a-t.a)<s&&Math.abs(this.b-t.b)<s&&Math.abs(this.c-t.c)<s&&Math.abs(this.d-t.d)<s&&Math.abs(this.e-t.e)<s&&Math.abs(this.f-t.f)<s}toString(){return`matrix(${this.a},${this.b},${this.c},${this.d},${this.e},${this.f})`}}F.IDENTITY=new F;F.IDENTITY.isIdentity=()=>!0;function Q(w){return typeof w=="number"?w?w<0?-1:1:w===w?w:NaN:NaN}class T{constructor(...t){this.coefs=[];for(let s=t.length-1;s>=0;s--)this.coefs.push(t[s]);this._variable="t",this._s=0}static interpolate(t,s,e,i,n){if(t.constructor!==Array||s.constructor!==Array)throw new TypeError("xs and ys must be arrays");if(isNaN(e)||isNaN(i)||isNaN(n))throw new TypeError("n, offset, and x must be numbers");let o,r,l=0;const c=new Array(e),y=new Array(e);let x=0,u=Math.abs(n-t[i]);for(o=0;o<e;o++){const a=Math.abs(n-t[i+o]);a<u&&(x=o,u=a),c[o]=y[o]=s[i+o]}r=s[i+x],x--;for(let a=1;a<e;a++){for(o=0;o<e-a;o++){const h=t[i+o]-n,d=t[i+o+a]-n,g=c[o+1]-y[o];let f=h-d;if(f===0)throw new RangeError("Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)");f=g/f,y[o]=d*f,c[o]=h*f}l=2*(x+1)<e-a?c[x+1]:y[x--],r+=l}return{y:r,dy:l}}static newtonSecantBisection(t,s,e,i,n,o){let r,l=0,c,y=0,x,u,a,h,d;r=t;const f=Math.pow(10,-14),p=typeof n=="number"&&typeof o=="number";if(p){if(n>o)throw new RangeError("Min must be greater than max");if(h=s(n),d=s(o),Q(h)===Q(d))throw new RangeError("Y values of bounds must be of opposite sign")}const b=function(){return Math.abs(x)<=f*Math.abs(r)||y===r-x-r};for(let P=0;P<i;P++){if(c=e(r),c===0){if(l===0)throw new RangeError("df(x) is zero");c=l}if(l=c,a=s(r),x=a/c,u=r-x,b())break;if(p){if(Q(a)===Q(d))o=r,d=a;else if(Q(a)===Q(h))n=r,h=a;else{r=u;break}if(u<n||u>o){if(Q(h)===Q(d))break;const L=50,A=.25,E=d-h,R=o-n;if(E===0?x=r-(n+R*.5):Math.abs(E/Math.min(h,d))>L?x=r-(n+R*(.5+(Math.abs(h)<Math.abs(d)?-A:A))):x=r-(n-h/E*R),u=r-x,b())break}}y=r-u,r=u}return r}clone(){const t=new T;return t.coefs=this.coefs.slice(),t}eval(t){if(isNaN(t))throw new TypeError(`Parameter must be a number. Found '${t}'`);let s=0;for(let e=this.coefs.length-1;e>=0;e--)s=s*t+this.coefs[e];return s}add(t){const s=new T,e=this.getDegree(),i=t.getDegree(),n=Math.max(e,i);for(let o=0;o<=n;o++){const r=o<=e?this.coefs[o]:0,l=o<=i?t.coefs[o]:0;s.coefs[o]=r+l}return s}multiply(t){const s=new T;for(let e=0;e<=this.getDegree()+t.getDegree();e++)s.coefs.push(0);for(let e=0;e<=this.getDegree();e++)for(let i=0;i<=t.getDegree();i++)s.coefs[e+i]+=this.coefs[e]*t.coefs[i];return s}divideEqualsScalar(t){for(let s=0;s<this.coefs.length;s++)this.coefs[s]/=t}simplifyEquals(t=1e-12){for(let s=this.getDegree();s>=0&&Math.abs(this.coefs[s])<=t;s--)this.coefs.pop()}removeZerosEquals(t=1e-15){const s=this.coefs,e=10*t*Math.abs(s.reduce((i,n)=>Math.abs(n)>Math.abs(i)?n:i));for(let i=0;i<s.length-1;i++)Math.abs(s[i])<e&&(s[i]=0);return this}monicEquals(){const t=this.coefs;return t[t.length-1]!==1&&this.divideEqualsScalar(t[t.length-1]),this}toString(){const t=[],s=[];for(let i=this.coefs.length-1;i>=0;i--){let n=Math.round(this.coefs[i]*1e3)/1e3;if(n!==0){const o=n<0?" - ":" + ";n=Math.abs(n),i>0&&(n===1?n=this._variable:n+=this._variable),i>1&&(n+="^"+i),s.push(o),t.push(n)}}s[0]=s[0]===" + "?"":"-";let e="";for(let i=0;i<t.length;i++)e+=s[i]+t[i];return e}bisection(t,s,e=1e-6,i=15){let n=this.eval(t),o=this.eval(s),r;if(Math.abs(n)<=e)r=t;else if(Math.abs(o)<=e)r=s;else if(n*o<=0){const l=Math.log(s-t),c=Math.LN10*i,y=Math.ceil((l+c)/Math.LN2);for(let x=0;x<y;x++){r=.5*(t+s);const u=this.eval(r);if(Math.abs(u)<=e)break;u*n<0?(s=r,o=u):(t=r,n=u)}}return r}trapezoid(t,s,e){if(isNaN(t)||isNaN(s)||isNaN(e))throw new TypeError("Parameters must be numbers");const i=s-t;if(e===1){const n=this.eval(t),o=this.eval(s);this._s=.5*i*(n+o)}else{const n=1<<e-2,o=i/n;let r=t+.5*o,l=0;for(let c=0;c<n;c++)l+=this.eval(r),r+=o;this._s=.5*(this._s+i*l/n)}if(isNaN(this._s))throw new TypeError("this._s is NaN");return this._s}simpson(t,s){if(isNaN(t)||isNaN(s))throw new TypeError("Parameters must be numbers");const e=s-t;let i=.5*e*(this.eval(t)+this.eval(s)),n=i,o=4*i/3,r=o,l=i;const c=1e-7;let y=1;for(let x=2;x<=20;x++){const u=e/y;let a=t+.5*u,h=0;for(let d=1;d<=y;d++)h+=this.eval(a),a+=u;if(n=.5*(n+e*h/y),i=n,o=(4*i-l)/3,Math.abs(o-r)<c*Math.abs(r))break;r=o,l=i,y<<=1}return o}romberg(t,s){if(isNaN(t)||isNaN(s))throw new TypeError("Parameters must be numbers");const e=20,i=3,n=1e-6,o=new Array(e+1),r=new Array(e+1);let l={y:0,dy:0};r[0]=1;for(let c=1;c<=e&&(o[c-1]=this.trapezoid(t,s,c),!(c>=i&&(l=T.interpolate(r,o,i,c-i,0),Math.abs(l.dy)<=n*l.y)));c++)o[c]=o[c-1],r[c]=.25*r[c-1];return l.y}zeroErrorEstimate(t){const s=this,e=1e-15;if(typeof t>"u"){const o=s.bounds();t=Math.max(Math.abs(o.minX),Math.abs(o.maxX))}if(t<.001)return 2*Math.abs(s.eval(e));const i=s.coefs.length-1,n=s.coefs[i];return 10*e*s.coefs.reduce((o,r,l)=>{const c=r/n*Math.pow(t,l);return c>o?c:o},0)}boundsUpperRealFujiwara(){let t=this.coefs;const s=t.length-1,e=t[s];e!==1&&(t=this.coefs.map(c=>c/e));const i=t.map((c,y)=>y<s?Math.pow(Math.abs(y===0?c/2:c),1/(s-y)):c);let n;const o=function(c,y,x){return n(x)&&(c.max<y?(c.nearmax=c.max,c.max=y):c.nearmax<y&&(c.nearmax=y)),c};n=function(c){return c<s&&t[c]<0};const r=i.reduce(o,{max:0,nearmax:0});return n=function(c){return c<s&&(s%2===c%2?t[c]<0:t[c]>0)},{negX:-2*i.reduce(o,{max:0,nearmax:0}).max,posX:2*r.max}}boundsLowerRealFujiwara(){const t=new T;t.coefs=this.coefs.slice().reverse();const s=t.boundsUpperRealFujiwara();return s.negX=1/s.negX,s.posX=1/s.posX,s}bounds(){const t=this.boundsUpperRealFujiwara(),s={minX:t.negX,maxX:t.posX};return t.negX===0&&t.posX===0||(t.negX===0?s.minX=this.boundsLowerRealFujiwara().posX:t.posX===0&&(s.maxX=this.boundsLowerRealFujiwara().negX),s.minX>s.maxX&&(s.minX=s.maxX=0)),s}boundUpperAbsRouche(){const t=this.coefs,s=t.length-1;return 1+t.reduce((i,n,o)=>o!==s?(n=Math.abs(n),i<n?n:i):i,0)/Math.abs(t[s])}boundLowerAbsRouche(){const t=this.coefs,s=t.reduce((e,i,n)=>n!==0?(i=Math.abs(i),e<i?i:e):e,0);return Math.abs(t[0])/(Math.abs(t[0])+s)}boundsRealLaguerre(){const t=this.coefs,s=t.length-1,e=-t[s-1]/(s*t[s]),i=t[s-1]*t[s-1]-2*s/(s-1)*t[s]*t[s-2];let n=(s-1)/(s*t[s])*Math.sqrt(i);return n<0&&(n=-n),{minX:e-n,maxX:e+n}}countRootsDescartes(){const t=this.coefs,s=t.length-1,e=t.reduce((i,n,o)=>(i.prev_a!==0&&n!==0&&(i.prev_a<0==n>0&&i.pos++,o%2===0!=i.prev_a<0==(o%2===1!=n>0)&&i.neg++),i.prev_a=n,i),{pos:0,neg:0,prev_a:0});return{maxRealPos:e.pos,maxRealNeg:e.neg,minComplex:s-(e.pos+e.neg)}}getDegree(){return this.coefs.length-1}getDerivative(){const t=new T;for(let s=1;s<this.coefs.length;s++)t.coefs.push(s*this.coefs[s]);return t}getRoots(){let t;switch(this.simplifyEquals(),this.getDegree()){case 0:t=[];break;case 1:t=this.getLinearRoot();break;case 2:t=this.getQuadraticRoots();break;case 3:t=this.getCubicRoots();break;case 4:t=this.getQuarticRoots();break;default:t=[]}return t}getRootsInInterval(t,s){const e=[];function i(n){typeof n=="number"&&e.push(n)}if(this.getDegree()===0)throw new RangeError("Unexpected empty polynomial");if(this.getDegree()===1)i(this.bisection(t,s));else{const o=this.getDerivative().getRootsInInterval(t,s);if(o.length>0){i(this.bisection(t,o[0]));for(let r=0;r<=o.length-2;r++)i(this.bisection(o[r],o[r+1]));i(this.bisection(o[o.length-1],s))}else i(this.bisection(t,s))}return e}getLinearRoot(){const t=[],s=this.coefs[1];return s!==0&&t.push(-this.coefs[0]/s),t}getQuadraticRoots(){const t=[];if(this.getDegree()===2){const s=this.coefs[2],e=this.coefs[1]/s,i=this.coefs[0]/s,n=e*e-4*i;if(n>0){const o=Math.sqrt(n);t.push(.5*(-e+o)),t.push(.5*(-e-o))}else n===0&&t.push(.5*-e)}return t}getCubicRoots(){const t=[];if(this.getDegree()===3){const s=this.coefs[3],e=this.coefs[2]/s,i=this.coefs[1]/s,n=this.coefs[0]/s,o=(3*i-e*e)/3,r=(2*e*e*e-9*i*e+27*n)/27,l=e/3;let c=r*r/4+o*o*o/27;const y=r/2,x=this.zeroErrorEstimate();if(Math.abs(c)<=x&&(c=0),c>0){const u=Math.sqrt(c);let a,h=-y+u;h>=0?a=Math.pow(h,1/3):a=-Math.pow(-h,1/3),h=-y-u,h>=0?a+=Math.pow(h,1/3):a-=Math.pow(-h,1/3),t.push(a-l)}else if(c<0){const u=Math.sqrt(-o/3),a=Math.atan2(Math.sqrt(-c),-y)/3,h=Math.cos(a),d=Math.sin(a),g=Math.sqrt(3);t.push(2*u*h-l),t.push(-u*(h+g*d)-l),t.push(-u*(h-g*d)-l)}else{let u;y>=0?u=-Math.pow(y,1/3):u=Math.pow(-y,1/3),t.push(2*u-l),t.push(-u-l)}}return t}getQuarticRoots(){let t=[];const s=this.getDegree();if(s===4){const e=new T;e.coefs=this.coefs.slice(),e.divideEqualsScalar(e.coefs[s]);const i=1e-15;Math.abs(e.coefs[0])<10*i*Math.abs(e.coefs[3])&&(e.coefs[0]=0);const n=e.getDerivative(),o=n.getRoots().sort((p,b)=>p-b),r=[],l=o.length-1,c=this.bounds(),y=Math.max(Math.abs(c.minX),Math.abs(c.maxX)),x=this.zeroErrorEstimate(y);for(let p=0;p<=l;p++)r.push(e.eval(o[p]));for(let p=0;p<=l;p++)Math.abs(r[p])<x&&(r[p]=0);let u=0;const a=Math.max(.1*(c.maxX-c.minX)/s,i),h=[],d=[];if(l>-1){for(r[0]!==0?Q(r[0])!==Q(e.eval(o[0]-a)-r[0])&&(h.push(o[0]-a),d.push([c.minX,o[0]])):(t.push(o[0],o[0]),u++);u<l;u++)r[u+1]===0?(t.push(o[u+1],o[u+1]),u++):Q(r[u])!==Q(r[u+1])&&(h.push((o[u]+o[u+1])/2),d.push([o[u],o[u+1]]));r[l]!==0&&Q(r[l])!==Q(e.eval(o[l]+a)-r[l])&&(h.push(o[l]+a),d.push([o[l],c.maxX]))}const g=function(p){return e.eval(p)},f=function(p){return n.eval(p)};if(h.length>0)for(u=0;u<h.length;u++)h[u]=T.newtonSecantBisection(h[u],g,f,32,d[u][0],d[u][1]);t=t.concat(h)}return t}}class H{constructor(t,s){this.type=t,this.text=s}typeis(t){return this.type===t}}H.UNDEFINED=0;H.COMMAND=1;H.NUMBER=2;H.EOD=3;class Yt{constructor(t){t==null&&(t=""),this.setPathData(t)}setPathData(t){if(typeof t!="string")throw new TypeError("The first parameter must be a string");this._pathData=t}getNextToken(){let t=null,s=this._pathData;for(;t===null;)if(s===null||s==="")t=new H(H.EOD,"");else if(s.match(/^([ \t\r\n,]+)/))s=s.substr(RegExp.$1.length);else if(s.match(/^([AaCcHhLlMmQqSsTtVvZz])/))t=new H(H.COMMAND,RegExp.$1),s=s.substr(RegExp.$1.length);else if(s.match(/^(([-+]?\d+(\.\d*)?|[-+]?\.\d+)([eE][-+]?\d+)?)/))t=new H(H.NUMBER,RegExp.$1),s=s.substr(RegExp.$1.length);else throw new SyntaxError(`Unrecognized path data: ${s}`);return this._pathData=s,t}}const xt="BOP";class et{constructor(){this._lexer=new Yt,this._handler=null}parseData(t){if(typeof t!="string")throw new TypeError(`The first parameter must be a string: ${t}`);this._handler!==null&&typeof this._handler.beginParse=="function"&&this._handler.beginParse();const s=this._lexer;s.setPathData(t);let e=xt,i=null,n=s.getNextToken();for(;n.typeis(H.EOD)===!1;){let o;const r=[];switch(n.type){case H.COMMAND:if(e===xt&&n.text!=="M"&&n.text!=="m")throw new SyntaxError(`New paths must begin with a moveto command. Found '${n.text}'`);e=n.text,o=et.PARAMCOUNT[n.text.toUpperCase()],n=s.getNextToken();break;case H.NUMBER:if(e===xt)throw new SyntaxError(`New paths must begin with a moveto command. Found '${n.text}'`);o=et.PARAMCOUNT[e.toUpperCase()];break;default:throw new SyntaxError(`Unrecognized command type: ${n.type}`)}for(let l=0;l<o;l++){switch(n.type){case H.COMMAND:throw new SyntaxError(`Parameter must be a number. Found '${n.text}'`);case H.NUMBER:r[l]=parseFloat(n.text);break;case H.EOD:throw new SyntaxError("Unexpected end of string");default:throw new SyntaxError(`Unrecognized parameter type. Found type '${n.type}'`)}n=s.getNextToken()}if(this._handler!==null){const l=this._handler,c=et.METHODNAME[e];(e==="a"||e==="A")&&(r[3]=r[3]!==0,r[4]=r[4]!==0),l!==null&&typeof l[c]=="function"&&l[c](...r)}switch(e){case"M":e="L";break;case"m":e="l";break;case"Z":case"z":e="BOP";break}if(n===i)throw new SyntaxError(`Parser stalled on '${n.text}'`);i=n}this._handler!==null&&typeof this._handler.endParse=="function"&&this._handler.endParse()}setHandler(t){this._handler=t}}et.PARAMCOUNT={A:7,C:6,H:1,L:2,M:2,Q:4,S:4,T:2,V:1,Z:0};et.METHODNAME={A:"arcAbs",a:"arcRel",C:"curvetoCubicAbs",c:"curvetoCubicRel",H:"linetoHorizontalAbs",h:"linetoHorizontalRel",L:"linetoAbs",l:"linetoRel",M:"movetoAbs",m:"movetoRel",Q:"curvetoQuadraticAbs",q:"curvetoQuadraticRel",S:"curvetoCubicSmoothAbs",s:"curvetoCubicSmoothRel",T:"curvetoQuadraticSmoothAbs",t:"curvetoQuadraticSmoothRel",V:"linetoVerticalAbs",v:"linetoVerticalRel",Z:"closePath",z:"closePath"};const Bt=2*Math.PI;function Pt(w,t,s,e,i,n,o){i=i*Math.PI/180;const r=Math.cos(i),l=Math.sin(i),c=1e-6,y=w.subtract(t).multiply(.5),x=y.x*r+y.y*l,u=y.x*-l+y.y*r;s=Math.abs(s),e=Math.abs(e);const a=x*x,h=u*u,d=a/(s*s)+h/(e*e);if(d>1){const V=Math.sqrt(d);s*=V,e*=V}const g=s*s,f=e*e,p=g*h,b=f*a;let P=(g*f-p-b)/(p+b);Math.abs(P)<c&&(P=0);let L=Math.sqrt(P);n===o&&(L=-L);const A=w.add(t).multiply(.5),E=L*s*u/e,R=L*-e*x/s,N=(x-E)/s,Y=(x+E)/s,v=(u-R)/e,k=(u+R)/e,B=new S(1,0).angleBetween(new S(N,v));let U=new S(N,v).angleBetween(new S(-Y,-k));return o===!1&&(U-=Bt),[E*r-R*l+A.x,E*l+R*r+A.y,s,e,B,B+U]}class kt{constructor(t){this.shapeCreator=t,this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}beginParse(){this.shapes=[],this.firstX=null,this.firstY=null,this.lastX=null,this.lastY=null,this.lastCommand=null}addShape(t){this.shapes.push(t)}arcAbs(t,s,e,i,n,o,r){if(t===0||s===0)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,o,r));else{const l=Pt(new M(this.lastX,this.lastY),new M(o,r),t,s,e,i,n);this.addShape(this.shapeCreator.arc(...l))}this.lastCommand="A",this.lastX=o,this.lastY=r}arcRel(t,s,e,i,n,o,r){if(t===0||s===0)this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+o,this.lastY+r));else{const l=Pt(new M(this.lastX,this.lastY),new M(this.lastX+o,this.lastY+r),t,s,e,i,n);this.addShape(this.shapeCreator.arc(...l))}this.lastCommand="a",this.lastX+=o,this.lastY+=r}curvetoCubicAbs(t,s,e,i,n,o){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,t,s,e,i,n,o)),this.lastX=n,this.lastY=o,this.lastCommand="C"}curvetoCubicRel(t,s,e,i,n,o){this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+s,this.lastX+e,this.lastY+i,this.lastX+n,this.lastY+o)),this.lastX+=n,this.lastY+=o,this.lastCommand="c"}linetoHorizontalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,this.lastY)),this.lastX=t,this.lastCommand="H"}linetoHorizontalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY)),this.lastX+=t,this.lastCommand="h"}linetoAbs(t,s){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,t,s)),this.lastX=t,this.lastY=s,this.lastCommand="L"}linetoRel(t,s){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX+t,this.lastY+s)),this.lastX+=t,this.lastY+=s,this.lastCommand="l"}movetoAbs(t,s){this.firstX=t,this.firstY=s,this.lastX=t,this.lastY=s,this.lastCommand="M"}movetoRel(t,s){this.firstX+=t,this.firstY+=s,this.lastX+=t,this.lastY+=s,this.lastCommand="m"}curvetoQuadraticAbs(t,s,e,i){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,t,s,e,i)),this.lastX=e,this.lastY=i,this.lastCommand="Q"}curvetoQuadraticRel(t,s,e,i){this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,this.lastX+t,this.lastY+s,this.lastX+e,this.lastY+i)),this.lastX+=e,this.lastY+=i,this.lastCommand="q"}curvetoCubicSmoothAbs(t,s,e,i){let n,o;if(this.lastCommand.match(/^[SsCc]$/)){const r=this.shapes[this.shapes.length-1].args[2];n=2*this.lastX-r.x,o=2*this.lastY-r.y}else n=this.lastX,o=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,n,o,t,s,e,i)),this.lastX=e,this.lastY=i,this.lastCommand="S"}curvetoCubicSmoothRel(t,s,e,i){let n,o;if(this.lastCommand.match(/^[SsCc]$/)){const r=this.shapes[this.shapes.length-1].args[2];n=2*this.lastX-r.x,o=2*this.lastY-r.y}else n=this.lastX,o=this.lastY;this.addShape(this.shapeCreator.cubicBezier(this.lastX,this.lastY,n,o,this.lastX+t,this.lastY+s,this.lastX+e,this.lastY+i)),this.lastX+=e,this.lastY+=i,this.lastCommand="s"}curvetoQuadraticSmoothAbs(t,s){let e,i;if(this.lastCommand.match(/^[QqTt]$/)){const n=this.shapes[this.shapes.length-1].args[1];e=2*this.lastX-n.x,i=2*this.lastY-n.y}else e=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,e,i,t,s)),this.lastX=t,this.lastY=s,this.lastCommand="T"}curvetoQuadraticSmoothRel(t,s){let e,i;if(this.lastCommand.match(/^[QqTt]$/)){const n=this.shapes[this.shapes.length-1].args[1];e=2*this.lastX-n.x,i=2*this.lastY-n.y}else e=this.lastX,i=this.lastY;this.addShape(this.shapeCreator.quadraticBezier(this.lastX,this.lastY,e,i,this.lastX+t,this.lastY+s)),this.lastX+=t,this.lastY+=s,this.lastCommand="t"}linetoVerticalAbs(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,t)),this.lastY=t,this.lastCommand="V"}linetoVerticalRel(t){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.lastX,this.lastY+t)),this.lastY+=t,this.lastCommand="v"}closePath(){this.addShape(this.shapeCreator.line(this.lastX,this.lastY,this.firstX,this.firstY)),this.lastX=this.firstX,this.lastY=this.firstY,this.lastCommand="z"}}const tt=Math.PI*.5,Ct=new et;function I(w,t){const s=[];for(const[e,i]of w){let n=null;if(i==="Point2D")n=ft(e,t);else if(i==="Number")n=Mt(e,t);else if(i==="Array<Point2D>"||i==="Point2D[]"){const o=[];for(;t.length>0;)o.push(ft(e,t));o.length>0&&(n=o)}else if(i==="Optional<Number>"||i==="Number?")n=Mt(e,t),n===null&&(n=void 0);else throw new TypeError(`Unrecognized value type: ${i}`);if(n!==null)s.push(n);else throw new TypeError(`Unable to extract value for ${e}`)}return s}function Mt(w,t){let s=null;if(t.length>0){const e=t[0],i=typeof e;if(i==="number")return t.shift();if(i==="object"){for(const n of w)if(n in e&&typeof e[n]=="number"){s=e[n];break}}}return s}function ft(w,t){let s=null;if(t.length>0){const e=t[0],i=typeof e;if(i==="number"){if(t.length>1){const n=t.shift(),o=t.shift();s=new M(n,o)}}else if(Array.isArray(e)&&e.length>1)if(e.length===2){const[n,o]=t.shift();s=new M(n,o)}else throw new TypeError(`Unhandled array of length ${e.length}`);else if(i==="object"){if("x"in e&&"y"in e)s=new M(e.x,e.y),t.shift();else for(const n of w)if(Array.isArray(n)){if(n.every(o=>o in e)){s=new M(e[n[0]],e[n[1]]);break}}else if(n in e){s=ft([],[e[n]]);break}}}return s}class C{constructor(t,s){this.name=t,this.args=s}static arc(...t){const e=I([[["center",["centerX","centerY"],["cx","cy"]],"Point2D"],[["radiusX","rx"],"Number"],[["radiusY","ry"],"Number"],[["startRadians"],"Number"],[["endRadians"],"Number"]],t);return new C(C.ARC,e)}static quadraticBezier(...t){const e=I([[["p1",["p1x","p1y"]],"Point2D"],[["p2",["p2x","p2y"]],"Point2D"],[["p3",["p3x","p3y"]],"Point2D"]],t);return new C(C.QUADRATIC_BEZIER,e)}static cubicBezier(...t){const e=I([[["p1",["p1x","p1y"]],"Point2D"],[["p2",["p2x","p2y"]],"Point2D"],[["p3",["p3x","p3y"]],"Point2D"],[["p4",["p4x","p4y"]],"Point2D"]],t);return new C(C.CUBIC_BEZIER,e)}static circle(...t){const e=I([[["center",["centerX","centerY"],["cx","cy"]],"Point2D"],[["radius","r"],"Number"]],t);return new C(C.CIRCLE,e)}static ellipse(...t){const e=I([[["center",["centerX","centerY"],["cx","cy"]],"Point2D"],[["radiusX","rx"],"Number"],[["radiusY","ry"],"Number"]],t);return new C(C.ELLIPSE,e)}static line(...t){const e=I([[["p1",["p1x","p1y"],["x1","y1"]],"Point2D"],[["p2",["p2x","p2y"],["x2","y2"]],"Point2D"]],t);return new C(C.LINE,e)}static path(...t){return Ct.parseData(t[0]),new C(C.PATH,Lt.shapes)}static polygon(...t){const e=I([[[],"Array<Point2D>"]],t.length===1&&Array.isArray(t[0])?t[0]:t);return new C(C.POLYGON,e)}static polyline(...t){const e=I([[[],"Array<Point2D>"]],t.length===1&&Array.isArray(t[0])?t[0]:t);return new C(C.POLYLINE,e)}static rectangle(...t){const e=I([[["topLeft",["x","y"],["left","top"]],"Point2D"],[["size",["width","height"],["w","h"]],"Point2D"],[["radiusX","rx"],"Optional<Number>"],[["radiusY","ry"],"Optional<Number>"]],t),i=e[0],n=e[1];e[1]=new M(i.x+n.x,i.y+n.y);const o=new C(C.RECTANGLE,e);let r=o.args.pop(),l=o.args.pop();if(l=l===void 0?0:l,r=r===void 0?0:r,l===0&&r===0)return o;const{x:c,y}=o.args[0],{x,y:u}=o.args[1],a=x-c,h=u-y;l===0&&(l=r),r===0&&(r=l),l>a*.5&&(l=a*.5),r>h*.5&&(r=h*.5);const d=c,g=y,f=c+l,p=y+r,b=x-l,P=u-r,L=x,A=u,E=[C.arc(f,p,l,r,2*tt,3*tt),C.line(f,g,b,g),C.arc(b,p,l,r,3*tt,4*tt),C.line(L,p,L,P),C.arc(b,P,l,r,0,tt),C.line(b,A,f,A),C.arc(f,P,l,r,tt,2*tt),C.line(d,P,d,p)];return new C(C.PATH,E)}}C.ARC="Arc";C.QUADRATIC_BEZIER="Bezier2";C.CUBIC_BEZIER="Bezier3";C.CIRCLE="Circle";C.ELLIPSE="Ellipse";C.LINE="Line";C.PATH="Path";C.POLYGON="Polygon";C.POLYLINE="Polyline";C.RECTANGLE="Rectangle";const Lt=new kt(C);Ct.setHandler(Lt);const lt=2*Math.PI,Tt=new S(1,0);function Rt(w){return w==null}function zt(w,t){const s=w[0]*t[1]-t[0]*w[1],e=w[0]*t[2]-t[0]*w[2],i=w[0]*t[3]-t[0]*w[3],n=w[0]*t[4]-t[0]*w[4],o=w[0]*t[5]-t[0]*w[5],r=w[1]*t[2]-t[1]*w[2],l=w[1]*t[4]-t[1]*w[4],c=w[1]*t[5]-t[1]*w[5],y=w[2]*t[3]-t[2]*w[3],x=w[3]*t[4]-t[3]*w[4],u=w[3]*t[5]-t[3]*w[5],a=c+x,h=l-y;return new T(s*r-e*e,s*h+i*r-2*e*n,s*a+i*h-n*n-2*e*o,s*u+i*a-2*n*o,i*u-o*o)}function qt(w){const t=w%lt;return t<0?t+lt:t}function Dt(w,t,s,e,i,n){if(w.points.length===0)return w;const o=new m("No Intersection");n<i&&([i,n]=[n,i]),(i<0||n<0)&&(i+=lt,n+=lt);for(const r of w.points){let l=qt(Tt.angleBetween(S.fromPoints(t,r)));l<i&&(l+=lt),i<=l&&l<=n&&o.appendPoint(r)}return o.points.length>0&&(o.status="Intersection"),o}function _(w){const t=w.slice();return t.push(w[0]),t}class m{constructor(t){this.init(t)}init(t){this.status=t,this.points=[]}static intersect(t,s){let e;if(!Rt(t)&&!Rt(s))if(t.name==="Path")e=m.intersectPathShape(t,s);else if(s.name==="Path")e=m.intersectPathShape(s,t);else if(t.name==="Arc")e=m.intersectArcShape(t,s);else if(s.name==="Arc")e=m.intersectArcShape(s,t);else{let i,n;if(t.name<s.name?(i="intersect"+t.name+s.name,n=t.args.concat(s.args)):(i="intersect"+s.name+t.name,n=s.args.concat(t.args)),!(i in m))throw new TypeError("Intersection not available: "+i);e=m[i].apply(null,n)}else e=new m("No Intersection");return e}static intersectPathShape(t,s){const e=new m("No Intersection");for(const i of t.args){const n=m.intersect(i,s);e.appendPoints(n.points)}return e.points.length>0&&(e.status="Intersection"),e}static intersectArcShape(t,s){const[e,i,n,o,r]=t.args,l=new C(C.ELLIPSE,[e,i,n]),c=m.intersect(l,s);return Dt(c,e,i,n,o,r)}static intersectBezier2Bezier2(t,s,e,i,n,o){let r,l;const c=new m("No Intersection");r=s.multiply(-2);const y=t.add(r.add(e));r=t.multiply(-2),l=s.multiply(2);const x=r.add(l),u=new M(t.x,t.y);r=n.multiply(-2);const a=i.add(r.add(o));r=i.multiply(-2),l=n.multiply(2);const h=r.add(l),d=new M(i.x,i.y);r=y.x*x.y-x.x*y.y,l=a.x*x.y-x.x*a.y;const g=h.x*x.y-x.x*h.y,f=x.x*(u.y-d.y)+x.y*(-u.x+d.x),p=a.x*y.y-y.x*a.y,b=h.x*y.y-y.x*h.y,P=y.x*(u.y-d.y)+y.y*(-u.x+d.x),A=new T(-p*p,-2*p*b,r*l-b*b-2*p*P,r*g-2*b*P,r*f-P*P).getRoots();for(const E of A)if(0<=E&&E<=1){const R=new T(y.x,x.x,u.x-d.x-E*h.x-E*E*a.x);R.simplifyEquals();const N=R.getRoots(),Y=new T(y.y,x.y,u.y-d.y-E*h.y-E*E*a.y);Y.simplifyEquals();const v=Y.getRoots();if(N.length>0&&v.length>0){t:for(const B of N)if(0<=B&&B<=1){for(let U=0;U<v.length;U++)if(Math.abs(B-v[U])<1e-4){c.points.push(a.multiply(E*E).add(h.multiply(E).add(d)));break t}}}}return c.points.length>0&&(c.status="Intersection"),c}static intersectBezier2Bezier3(t,s,e,i,n,o,r){let l,c,y,x;const u=new m("No Intersection");l=s.multiply(-2);const a=t.add(l.add(e));l=t.multiply(-2),c=s.multiply(2);const h=l.add(c),d=new M(t.x,t.y);l=i.multiply(-1),c=n.multiply(3),y=o.multiply(-3),x=l.add(c.add(y.add(r)));const g=new M(x.x,x.y);l=i.multiply(3),c=n.multiply(-6),y=o.multiply(3),x=l.add(c.add(y));const f=new M(x.x,x.y);l=i.multiply(-3),c=n.multiply(3),y=l.add(c);const p=new M(y.x,y.y),b=new M(i.x,i.y),P=d.x*d.x,L=d.y*d.y,A=h.x*h.x,E=h.y*h.y,R=a.x*a.x,N=a.y*a.y,Y=b.x*b.x,v=b.y*b.y,k=p.x*p.x,B=p.y*p.y,U=f.x*f.x,V=f.y*f.y,W=g.x*g.x,K=g.y*g.y,q=new T(-2*a.x*a.y*g.x*g.y+R*K+N*W,-2*a.x*a.y*f.x*g.y-2*a.x*a.y*f.y*g.x+2*N*f.x*g.x+2*R*f.y*g.y,-2*a.x*p.x*a.y*g.y-2*a.x*a.y*p.y*g.x-2*a.x*a.y*f.x*f.y+2*p.x*N*g.x+N*U+R*(2*p.y*g.y+V),2*d.x*a.x*a.y*g.y+2*d.y*a.x*a.y*g.x+h.x*h.y*a.x*g.y+h.x*h.y*a.y*g.x-2*b.x*a.x*a.y*g.y-2*a.x*b.y*a.y*g.x-2*a.x*p.x*a.y*f.y-2*a.x*a.y*p.y*f.x-2*d.x*N*g.x-2*d.y*R*g.y+2*b.x*N*g.x+2*p.x*N*f.x-E*a.x*g.x-A*a.y*g.y+R*(2*b.y*g.y+2*p.y*f.y),2*d.x*a.x*a.y*f.y+2*d.y*a.x*a.y*f.x+h.x*h.y*a.x*f.y+h.x*h.y*a.y*f.x-2*b.x*a.x*a.y*f.y-2*a.x*b.y*a.y*f.x-2*a.x*p.x*a.y*p.y-2*d.x*N*f.x-2*d.y*R*f.y+2*b.x*N*f.x-E*a.x*f.x-A*a.y*f.y+k*N+R*(2*b.y*f.y+B),2*d.x*a.x*a.y*p.y+2*d.y*a.x*p.x*a.y+h.x*h.y*a.x*p.y+h.x*h.y*p.x*a.y-2*b.x*a.x*a.y*p.y-2*a.x*b.y*p.x*a.y-2*d.x*p.x*N-2*d.y*R*p.y+2*b.x*p.x*N-E*a.x*p.x-A*a.y*p.y+2*R*b.y*p.y,-2*d.x*d.y*a.x*a.y-d.x*h.x*h.y*a.y-d.y*h.x*h.y*a.x+2*d.x*a.x*b.y*a.y+2*d.y*b.x*a.x*a.y+h.x*b.x*h.y*a.y+h.x*h.y*a.x*b.y-2*b.x*a.x*b.y*a.y-2*d.x*b.x*N+d.x*E*a.x+d.y*A*a.y-2*d.y*R*b.y-b.x*E*a.x-A*b.y*a.y+P*N+L*R+Y*N+R*v).getRootsInInterval(0,1);for(const X of q){const z=new T(a.x,h.x,d.x-b.x-X*p.x-X*X*f.x-X*X*X*g.x).getRoots(),j=new T(a.y,h.y,d.y-b.y-X*p.y-X*X*f.y-X*X*X*g.y).getRoots();if(z.length>0&&j.length>0){t:for(const Z of z)if(0<=Z&&Z<=1){for(let G=0;G<j.length;G++)if(Math.abs(Z-j[G])<1e-4){u.points.push(g.multiply(X*X*X).add(f.multiply(X*X).add(p.multiply(X).add(b))));break t}}}}return u.points.length>0&&(u.status="Intersection"),u}static intersectBezier2Circle(t,s,e,i,n){return m.intersectBezier2Ellipse(t,s,e,i,n,n)}static intersectBezier2Ellipse(t,s,e,i,n,o){let r;const l=new m("No Intersection");r=s.multiply(-2);const c=t.add(r.add(e));r=t.multiply(-2);const y=s.multiply(2),x=r.add(y),u=new M(t.x,t.y),a=n*n,h=o*o,d=new T(h*c.x*c.x+a*c.y*c.y,2*(h*c.x*x.x+a*c.y*x.y),h*(2*c.x*u.x+x.x*x.x)+a*(2*c.y*u.y+x.y*x.y)-2*(h*i.x*c.x+a*i.y*c.y),2*(h*x.x*(u.x-i.x)+a*x.y*(u.y-i.y)),h*(u.x*u.x+i.x*i.x)+a*(u.y*u.y+i.y*i.y)-2*(h*i.x*u.x+a*i.y*u.y)-a*h).getRoots();for(const g of d)0<=g&&g<=1&&l.points.push(c.multiply(g*g).add(x.multiply(g).add(u)));return l.points.length>0&&(l.status="Intersection"),l}static intersectBezier2Line(t,s,e,i,n){let o;const r=i.min(n),l=i.max(n),c=new m("No Intersection");o=s.multiply(-2);const y=t.add(o.add(e));o=t.multiply(-2);const x=s.multiply(2),u=o.add(x),a=new M(t.x,t.y),h=new S(i.y-n.y,n.x-i.x),d=i.x*n.y-n.x*i.y,g=new T(h.dot(y),h.dot(u),h.dot(a)+d).getRoots();for(const f of g)if(0<=f&&f<=1){const p=t.lerp(s,f),b=s.lerp(e,f),P=p.lerp(b,f);i.x===n.x?r.y<=P.y&&P.y<=l.y&&(c.status="Intersection",c.appendPoint(P)):i.y===n.y?r.x<=P.x&&P.x<=l.x&&(c.status="Intersection",c.appendPoint(P)):r.x<=P.x&&P.x<=l.x&&r.y<=P.y&&P.y<=l.y&&(c.status="Intersection",c.appendPoint(P))}return c}static intersectBezier2Polygon(t,s,e,i){return m.intersectBezier2Polyline(t,s,e,_(i))}static intersectBezier2Polyline(t,s,e,i){const n=new m("No Intersection"),{length:o}=i;for(let r=0;r<o-1;r++){const l=i[r],c=i[r+1],y=m.intersectBezier2Line(t,s,e,l,c);n.appendPoints(y.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectBezier2Rectangle(t,s,e,i,n){const o=i.min(n),r=i.max(n),l=new M(r.x,o.y),c=new M(o.x,r.y),y=m.intersectBezier2Line(t,s,e,o,l),x=m.intersectBezier2Line(t,s,e,l,r),u=m.intersectBezier2Line(t,s,e,r,c),a=m.intersectBezier2Line(t,s,e,c,o),h=new m("No Intersection");return h.appendPoints(y.points),h.appendPoints(x.points),h.appendPoints(u.points),h.appendPoints(a.points),h.points.length>0&&(h.status="Intersection"),h}static intersectBezier3Bezier3(t,s,e,i,n,o,r,l){let c,y,x,u;const a=new m("No Intersection");c=t.multiply(-1),y=s.multiply(3),x=e.multiply(-3),u=c.add(y.add(x.add(i)));const h=new M(u.x,u.y);c=t.multiply(3),y=s.multiply(-6),x=e.multiply(3),u=c.add(y.add(x));const d=new M(u.x,u.y);c=t.multiply(-3),y=s.multiply(3),x=c.add(y);const g=new M(x.x,x.y),f=new M(t.x,t.y);c=n.multiply(-1),y=o.multiply(3),x=r.multiply(-3),u=c.add(y.add(x.add(l)));const p=new M(u.x,u.y);c=n.multiply(3),y=o.multiply(-6),x=r.multiply(3),u=c.add(y.add(x));const b=new M(u.x,u.y);c=n.multiply(-3),y=o.multiply(3),x=c.add(y);const P=new M(x.x,x.y),L=new M(n.x,n.y);c=h.x*d.y-d.x*h.y,y=h.x*g.y-g.x*h.y;const A=h.x*f.y-f.x*h.y+L.x*h.y-h.x*L.y,E=P.x*h.y-h.x*P.y,R=b.x*h.y-h.x*b.y,N=p.x*h.y-h.x*p.y;u=h.x*g.y-g.x*h.y;const Y=h.x*f.y+d.x*g.y-g.x*d.y-f.x*h.y+L.x*h.y-h.x*L.y,v=P.x*h.y-h.x*P.y,k=b.x*h.y-h.x*b.y,B=p.x*h.y-h.x*p.y,U=d.x*f.y-f.x*d.y+L.x*d.y-d.x*L.y,V=P.x*d.y-d.x*P.y,W=b.x*d.y-d.x*b.y,K=p.x*d.y-d.x*p.y,D=h.x*f.y-f.x*h.y+L.x*h.y-h.x*L.y,q=P.x*h.y-h.x*P.y,X=b.x*h.y-h.x*b.y,z=p.x*h.y-h.x*p.y,j=d.x*f.y-f.x*d.y+L.x*d.y-d.x*L.y,J=P.x*d.y-d.x*P.y,Z=b.x*d.y-d.x*b.y,G=p.x*d.y-d.x*p.y,nt=g.x*f.y-f.x*g.y+L.x*g.y-g.x*L.y,it=P.x*g.y-g.x*P.y,ot=b.x*g.y-g.x*b.y,rt=p.x*g.y-g.x*p.y,gt=new T(-N*B*z,-N*B*X-N*k*z-R*B*z,-N*B*q-N*k*X-R*B*X-N*v*z-R*k*z-E*B*z,-N*B*D-N*k*q-R*B*q-N*v*X-R*k*X-E*B*X-N*Y*z-R*v*z-E*k*z-A*B*z+y*K*z+N*u*G-c*K*G+c*B*rt,-N*k*D-R*B*D-N*v*q-R*k*q-E*B*q-N*Y*X-R*v*X-E*k*X-A*B*X+y*K*X-R*Y*z-E*v*z-A*k*z+y*W*z+N*u*Z-c*K*Z+R*u*G-c*W*G+c*B*ot+c*k*rt,-N*v*D-R*k*D-E*B*D-N*Y*q-R*v*q-E*k*q-A*B*q+y*K*q-R*Y*X-E*v*X-A*k*X+y*W*X-E*Y*z-A*v*z+y*V*z+N*u*J-c*K*J+R*u*Z-c*W*Z+E*u*G-c*V*G+c*B*it+c*k*ot+c*v*rt,-N*Y*D-R*v*D-E*k*D-A*B*D+y*K*D-R*Y*q-E*v*q-A*k*q+y*W*q-E*Y*X-A*v*X+y*V*X-A*Y*z+y*U*z+N*u*j-c*K*j+R*u*J-c*W*J+E*u*Z-c*V*Z+A*u*G-c*U*G+c*B*nt+c*k*it+c*v*ot-y*u*rt+c*Y*rt,-R*Y*D-E*v*D-A*k*D+y*W*D-E*Y*q-A*v*q+y*V*q-A*Y*X+y*U*X+R*u*j-c*W*j+E*u*J-c*V*J+A*u*Z-c*U*Z+c*k*nt+c*v*it-y*u*ot+c*Y*ot,-E*Y*D-A*v*D+y*V*D-A*Y*q+y*U*q+E*u*j-c*V*j+A*u*J-c*U*J+c*v*nt-y*u*it+c*Y*it,-A*Y*D+y*U*D+A*u*j-c*U*j-y*u*nt+c*Y*nt);gt.simplifyEquals();const Xt=gt.getRootsInInterval(0,1);for(const O of Xt){const wt=new T(h.x,d.x,g.x,f.x-L.x-O*P.x-O*O*b.x-O*O*O*p.x);wt.simplifyEquals();const bt=wt.getRoots(),Et=new T(h.y,d.y,g.y,f.y-L.y-O*P.y-O*O*b.y-O*O*O*p.y);Et.simplifyEquals();const ut=Et.getRoots();if(bt.length>0&&ut.length>0){t:for(const yt of bt)if(0<=yt&&yt<=1){for(let dt=0;dt<ut.length;dt++)if(Math.abs(yt-ut[dt])<1e-4){a.points.push(p.multiply(O*O*O).add(b.multiply(O*O).add(P.multiply(O).add(L))));break t}}}}return a.points.length>0&&(a.status="Intersection"),a}static intersectBezier3Circle(t,s,e,i,n,o){return m.intersectBezier3Ellipse(t,s,e,i,n,o,o)}static intersectBezier3Ellipse(t,s,e,i,n,o,r){let l,c,y,x;const u=new m("No Intersection");l=t.multiply(-1),c=s.multiply(3),y=e.multiply(-3),x=l.add(c.add(y.add(i)));const a=new M(x.x,x.y);l=t.multiply(3),c=s.multiply(-6),y=e.multiply(3),x=l.add(c.add(y));const h=new M(x.x,x.y);l=t.multiply(-3),c=s.multiply(3),y=l.add(c);const d=new M(y.x,y.y),g=new M(t.x,t.y),f=o*o,p=r*r,P=new T(a.x*a.x*p+a.y*a.y*f,2*(a.x*h.x*p+a.y*h.y*f),2*(a.x*d.x*p+a.y*d.y*f)+h.x*h.x*p+h.y*h.y*f,2*a.x*p*(g.x-n.x)+2*a.y*f*(g.y-n.y)+2*(h.x*d.x*p+h.y*d.y*f),2*h.x*p*(g.x-n.x)+2*h.y*f*(g.y-n.y)+d.x*d.x*p+d.y*d.y*f,2*d.x*p*(g.x-n.x)+2*d.y*f*(g.y-n.y),g.x*g.x*p-2*g.y*n.y*f-2*g.x*n.x*p+g.y*g.y*f+n.x*n.x*p+n.y*n.y*f-f*p).getRootsInInterval(0,1);for(const L of P)u.points.push(a.multiply(L*L*L).add(h.multiply(L*L).add(d.multiply(L).add(g))));return u.points.length>0&&(u.status="Intersection"),u}static intersectBezier3Line(t,s,e,i,n,o){let r,l,c,y;const x=n.min(o),u=n.max(o),a=new m("No Intersection");r=t.multiply(-1),l=s.multiply(3),c=e.multiply(-3),y=r.add(l.add(c.add(i)));const h=new S(y.x,y.y);r=t.multiply(3),l=s.multiply(-6),c=e.multiply(3),y=r.add(l.add(c));const d=new S(y.x,y.y);r=t.multiply(-3),l=s.multiply(3),c=r.add(l);const g=new S(c.x,c.y),f=new S(t.x,t.y),p=new S(n.y-o.y,o.x-n.x),b=n.x*o.y-o.x*n.y,P=new T(p.dot(h),p.dot(d),p.dot(g),p.dot(f)+b).getRoots();for(const L of P)if(0<=L&&L<=1){const A=t.lerp(s,L),E=s.lerp(e,L),R=e.lerp(i,L),N=A.lerp(E,L),Y=E.lerp(R,L),v=N.lerp(Y,L);n.x===o.x?x.y<=v.y&&v.y<=u.y&&(a.status="Intersection",a.appendPoint(v)):n.y===o.y?x.x<=v.x&&v.x<=u.x&&(a.status="Intersection",a.appendPoint(v)):x.x<=v.x&&v.x<=u.x&&x.y<=v.y&&v.y<=u.y&&(a.status="Intersection",a.appendPoint(v))}return a}static intersectBezier3Polygon(t,s,e,i,n){return m.intersectBezier3Polyline(t,s,e,i,_(n))}static intersectBezier3Polyline(t,s,e,i,n){const o=new m("No Intersection"),{length:r}=n;for(let l=0;l<r-1;l++){const c=n[l],y=n[l+1],x=m.intersectBezier3Line(t,s,e,i,c,y);o.appendPoints(x.points)}return o.points.length>0&&(o.status="Intersection"),o}static intersectBezier3Rectangle(t,s,e,i,n,o){const r=n.min(o),l=n.max(o),c=new M(l.x,r.y),y=new M(r.x,l.y),x=m.intersectBezier3Line(t,s,e,i,r,c),u=m.intersectBezier3Line(t,s,e,i,c,l),a=m.intersectBezier3Line(t,s,e,i,l,y),h=m.intersectBezier3Line(t,s,e,i,y,r),d=new m("No Intersection");return d.appendPoints(x.points),d.appendPoints(u.points),d.appendPoints(a.points),d.appendPoints(h.points),d.points.length>0&&(d.status="Intersection"),d}static intersectCircleCircle(t,s,e,i){let n;const o=s+i,r=Math.abs(s-i),l=t.distanceFrom(e);if(l>o)n=new m("Outside");else if(l<r)n=new m("Inside");else{n=new m("Intersection");const c=(s*s-i*i+l*l)/(2*l),y=Math.sqrt(s*s-c*c),x=t.lerp(e,c/l),u=y/l;n.points.push(new M(x.x-u*(e.y-t.y),x.y+u*(e.x-t.x))),n.points.push(new M(x.x+u*(e.y-t.y),x.y-u*(e.x-t.x)))}return n}static intersectCircleEllipse(t,s,e,i,n){return m.intersectEllipseEllipse(t,s,s,e,i,n)}static intersectCircleLine(t,s,e,i){let n;const o=(i.x-e.x)*(i.x-e.x)+(i.y-e.y)*(i.y-e.y),r=2*((i.x-e.x)*(e.x-t.x)+(i.y-e.y)*(e.y-t.y)),l=t.x*t.x+t.y*t.y+e.x*e.x+e.y*e.y-2*(t.x*e.x+t.y*e.y)-s*s,c=r*r-4*o*l;if(c<0)n=new m("Outside");else if(c===0)n=new m("Tangent");else{const y=Math.sqrt(c),x=(-r+y)/(2*o),u=(-r-y)/(2*o);(x<0||x>1)&&(u<0||u>1)?x<0&&u<0||x>1&&u>1?n=new m("Outside"):n=new m("Inside"):(n=new m("Intersection"),0<=x&&x<=1&&n.points.push(e.lerp(i,x)),0<=u&&u<=1&&n.points.push(e.lerp(i,u)))}return n}static intersectCirclePolygon(t,s,e){return m.intersectCirclePolyline(t,s,_(e))}static intersectCirclePolyline(t,s,e){const i=new m("No Intersection"),{length:n}=e;let o;for(let r=0;r<n-1;r++){const l=e[r],c=e[r+1];o=m.intersectCircleLine(t,s,l,c),i.appendPoints(o.points)}return i.points.length>0?i.status="Intersection":i.status=o.status,i}static intersectCircleRectangle(t,s,e,i){const n=e.min(i),o=e.max(i),r=new M(o.x,n.y),l=new M(n.x,o.y),c=m.intersectCircleLine(t,s,n,r),y=m.intersectCircleLine(t,s,r,o),x=m.intersectCircleLine(t,s,o,l),u=m.intersectCircleLine(t,s,l,n),a=new m("No Intersection");return a.appendPoints(c.points),a.appendPoints(y.points),a.appendPoints(x.points),a.appendPoints(u.points),a.points.length>0?a.status="Intersection":a.status=c.status,a}static intersectEllipseEllipse(t,s,e,i,n,o){const r=[e*e,0,s*s,-2*e*e*t.x,-2*s*s*t.y,e*e*t.x*t.x+s*s*t.y*t.y-s*s*e*e],l=[o*o,0,n*n,-2*o*o*i.x,-2*n*n*i.y,o*o*i.x*i.x+n*n*i.y*i.y-n*n*o*o],y=zt(r,l).getRoots(),x=.001,u=(r[0]*r[0]+2*r[1]*r[1]+r[2]*r[2])*x,a=(l[0]*l[0]+2*l[1]*l[1]+l[2]*l[2])*x,h=new m("No Intersection");for(let d=0;d<y.length;d++){const f=new T(r[0],r[3]+y[d]*r[1],r[5]+y[d]*(r[4]+y[d]*r[2])).getRoots();for(let p=0;p<f.length;p++){let b=(r[0]*f[p]+r[1]*y[d]+r[3])*f[p]+(r[2]*y[d]+r[4])*y[d]+r[5];Math.abs(b)<u&&(b=(l[0]*f[p]+l[1]*y[d]+l[3])*f[p]+(l[2]*y[d]+l[4])*y[d]+l[5],Math.abs(b)<a&&h.appendPoint(new M(f[p],y[d])))}}return h.points.length>0&&(h.status="Intersection"),h}static intersectEllipseLine(t,s,e,i,n){let o;const r=new S(i.x,i.y),l=S.fromPoints(i,n),c=new S(t.x,t.y),y=r.subtract(c),x=new S(l.x/(s*s),l.y/(e*e)),u=new S(y.x/(s*s),y.y/(e*e)),a=l.dot(x),h=l.dot(u);t=y.dot(u)-1;const d=h*h-a*t;if(d<0)o=new m("Outside");else if(d>0){const g=Math.sqrt(d),f=(-h-g)/a,p=(-h+g)/a;(f<0||1<f)&&(p<0||1<p)?f<0&&p<0||f>1&&p>1?o=new m("Outside"):o=new m("Inside"):(o=new m("Intersection"),0<=f&&f<=1&&o.appendPoint(i.lerp(n,f)),0<=p&&p<=1&&o.appendPoint(i.lerp(n,p)))}else{const g=-h/a;0<=g&&g<=1?(o=new m("Intersection"),o.appendPoint(i.lerp(n,g))):o=new m("Outside")}return o}static intersectEllipsePolygon(t,s,e,i){return m.intersectEllipsePolyline(t,s,e,_(i))}static intersectEllipsePolyline(t,s,e,i){const n=new m("No Intersection"),{length:o}=i;for(let r=0;r<o-1;r++){const l=i[r],c=i[r+1],y=m.intersectEllipseLine(t,s,e,l,c);n.appendPoints(y.points)}return n.points.length>0&&(n.status="Intersection"),n}static intersectEllipseRectangle(t,s,e,i,n){const o=i.min(n),r=i.max(n),l=new M(r.x,o.y),c=new M(o.x,r.y),y=m.intersectEllipseLine(t,s,e,o,l),x=m.intersectEllipseLine(t,s,e,l,r),u=m.intersectEllipseLine(t,s,e,r,c),a=m.intersectEllipseLine(t,s,e,c,o),h=new m("No Intersection");return h.appendPoints(y.points),h.appendPoints(x.points),h.appendPoints(u.points),h.appendPoints(a.points),h.points.length>0&&(h.status="Intersection"),h}static intersectLineLine(t,s,e,i){let n;const o=(i.x-e.x)*(t.y-e.y)-(i.y-e.y)*(t.x-e.x),r=(s.x-t.x)*(t.y-e.y)-(s.y-t.y)*(t.x-e.x),l=(i.y-e.y)*(s.x-t.x)-(i.x-e.x)*(s.y-t.y);if(l!==0){const c=o/l,y=r/l;0<=c&&c<=1&&0<=y&&y<=1?(n=new m("Intersection"),n.points.push(new M(t.x+c*(s.x-t.x),t.y+c*(s.y-t.y)))):n=new m("No Intersection")}else o===0||r===0?n=new m("Coincident"):n=new m("Parallel");return n}static intersectLinePolygon(t,s,e){return m.intersectLinePolyline(t,s,_(e))}static intersectLinePolyline(t,s,e){const i=new m("No Intersection"),{length:n}=e;for(let o=0;o<n-1;o++){const r=e[o],l=e[o+1],c=m.intersectLineLine(t,s,r,l);i.appendPoints(c.points)}return i.points.length>0&&(i.status="Intersection"),i}static intersectLineRectangle(t,s,e,i){const n=e.min(i),o=e.max(i),r=new M(o.x,n.y),l=new M(n.x,o.y),c=m.intersectLineLine(n,r,t,s),y=m.intersectLineLine(r,o,t,s),x=m.intersectLineLine(o,l,t,s),u=m.intersectLineLine(l,n,t,s),a=new m("No Intersection");return a.appendPoints(c.points),a.appendPoints(y.points),a.appendPoints(x.points),a.appendPoints(u.points),a.points.length>0&&(a.status="Intersection"),a}static intersectPolygonPolygon(t,s){return m.intersectPolylinePolyline(_(t),_(s))}static intersectPolygonPolyline(t,s){return m.intersectPolylinePolyline(_(t),s)}static intersectPolygonRectangle(t,s,e){return m.intersectPolylineRectangle(_(t),s,e)}static intersectPolylinePolyline(t,s){const e=new m("No Intersection"),{length:i}=t;for(let n=0;n<i-1;n++){const o=t[n],r=t[n+1],l=m.intersectLinePolyline(o,r,s);e.appendPoints(l.points)}return e.points.length>0&&(e.status="Intersection"),e}static intersectPolylineRectangle(t,s,e){const i=s.min(e),n=s.max(e),o=new M(n.x,i.y),r=new M(i.x,n.y),l=m.intersectLinePolyline(i,o,t),c=m.intersectLinePolyline(o,n,t),y=m.intersectLinePolyline(n,r,t),x=m.intersectLinePolyline(r,i,t),u=new m("No Intersection");return u.appendPoints(l.points),u.appendPoints(c.points),u.appendPoints(y.points),u.appendPoints(x.points),u.points.length>0&&(u.status="Intersection"),u}static intersectRectangleRectangle(t,s,e,i){const n=t.min(s),o=t.max(s),r=new M(o.x,n.y),l=new M(n.x,o.y),c=m.intersectLineRectangle(n,r,e,i),y=m.intersectLineRectangle(r,o,e,i),x=m.intersectLineRectangle(o,l,e,i),u=m.intersectLineRectangle(l,n,e,i),a=new m("No Intersection");return a.appendPoints(c.points),a.appendPoints(y.points),a.appendPoints(x.points),a.appendPoints(u.points),a.points.length>0&&(a.status="Intersection"),a}static intersectRayRay(t,s,e,i){let n;const o=(i.x-e.x)*(t.y-e.y)-(i.y-e.y)*(t.x-e.x),r=(s.x-t.x)*(t.y-e.y)-(s.y-t.y)*(t.x-e.x),l=(i.y-e.y)*(s.x-t.x)-(i.x-e.x)*(s.y-t.y);if(l!==0){const c=o/l;n=new m("Intersection"),n.points.push(new M(t.x+c*(s.x-t.x),t.y+c*(s.y-t.y)))}else o===0||r===0?n=new m("Coincident"):n=new m("Parallel");return n}appendPoint(t){this.points.push(t)}appendPoints(t){this.points=this.points.concat(t)}}const St=["picture","check_tree","check_boundaries","check_arrowheads","check_shortcuts","check_all","check_bounding_box","winding_number","check_winding_numbers"];let $={};for(const w of St)$[w]=document.getElementById(w);const Ot=new URLSearchParams(document.location.search),$t=Ot.get("svg"),Ut=await fetch("/shortcut-tree/"+$t);$.picture.innerHTML=await Ut.text();const at=document.getElementsByTagName("svg")[0];at.innerHTML+='<g id="winding" style="pointer-events: none;"></g>';const Ft=document.getElementsByClassName("segment"),Nt=document.getElementsByClassName("treenode");let st=null;function vt(w){for(const t of Ft)t.setAttribute("opacity",w);for(const t of Nt)t.setAttribute("opacity",w)}for(const w of Nt)w.addEventListener("mouseenter",()=>{if(vt(.1),At(),document.querySelector("#check_shortcuts").checked)for(const s of w.querySelectorAll(".shortcut"))s.style.visibility="visible";st=w,w.setAttribute("opacity",1);const t=w.getAttribute("segments");if(t!=="")for(const s of t.split(" "))document.getElementById(s).setAttribute("opacity",1)});function At(){for(const w of document.querySelectorAll(".shortcut"))w.style.visibility="hidden"}function Ht(w){return w.args[0].args[0]}function pt(w,t,s){let e=0;for(const i of s){const n=C.path(i.getAttribute("d")),o=m.intersect(n,t);for(const r of o.points){const l=Ht(n);e+=l.y>r.y?1:-1,w.innerHTML+=`<circle cx="${r.x}" cy="${r.y}" fill="red" r="2" />`}}return e}const ct=document.getElementById("winding");at.addEventListener("mouseleave",()=>{vt(1),At(),st=null,$.winding_number.innerHTML="",ct.innerHTML=""});at.addEventListener("mousemove",w=>{const t=at.createSVGPoint();t.x=w.clientX,t.y=w.clientY;const s=t.matrixTransform(at.getScreenCTM().inverse());ct.innerHTML=`
    <circle cx="${s.x}" cy="${s.y}" r="2" fill="red" />
    <line x1="${s.x}" y1="${s.y}" x2="200" y2="${s.y}" stroke="red" />
  `;let e=st&&$.check_winding_numbers.checked?parseInt(st.querySelector(".winding_number").innerHTML):0;const i=C.line([s.x,s.y],[200,s.y]);if(st){const n=st.getAttribute("segments");if(n!=="")for(const o of n.split(" "))e+=pt(ct,i,document.querySelectorAll(`#${o} path`));$.check_shortcuts.checked&&$.check_tree.checked&&(e+=pt(ct,i,st.querySelectorAll(".shortcut")))}else e+=pt(ct,i,document.querySelectorAll(".segment path"));$.winding_number.innerHTML=e.toString(),$.winding_number.style.top=`calc(${w.clientY}px - 0.7em)`});function ht(w,t,s,e,i){w.checked=i;const n=()=>{const o=w.checked?!e:e;for(const r of document.querySelectorAll(t))r.classList.toggle(s,o)};w.addEventListener("change",n),n()}ht($.check_tree,".treenode","invisible",!0,!1);ht($.check_boundaries,".segmentBoundary","invisible",!0,!1);ht($.check_arrowheads,".firstHalf","arrowhead",!1,!1);ht($.check_bounding_box,".segment_bounding_box","invisible",!0,!1);ht($.check_winding_numbers,".winding_number","invisible",!0,!1);$.check_all.addEventListener("change",()=>{const w=$.check_all.checked,t=new Event("change");for(const s of document.querySelectorAll('input[type="checkbox"]'))s!==check_all&&(s.checked=w,s.dispatchEvent(t))});const mt=document.querySelectorAll(".original");for(const w of mt)w.style.stroke="none",w.style.fill="none";const Qt=[document.getElementById("fill_none"),document.getElementById("fill_nonzero"),document.getElementById("fill_evenodd")];for(const w of Qt)w.addEventListener("change",()=>{if(w.checked)for(const t of mt)w.value==="none"?t.style.fill="none":($.check_tree.checked?t.style.fill="#eee":t.style.fill="black",t.style["fill-rule"]=w.value)});$.check_tree.addEventListener("change",()=>{if(!document.getElementById("fill_none").checked)for(const w of mt)w.style.fill=$.check_tree.checked?"#eee":"black"});
